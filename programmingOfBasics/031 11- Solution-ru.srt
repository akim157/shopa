1

00:00:00,000 --> 00:00:04,000

Хорошо, так вот мой



2

00:00:04,000 --> 00:00:08,000

решение. Я собираюсь выбрать эти три метода,



3

00:00:08,000 --> 00:00:12,000

начать, остановить и сбросить,



4

00:00:12,000 --> 00:00:16,000

и переместить их за пределы этой функции.



5

00:00:16,000 --> 00:00:20,000

Теперь я собираюсь заменить это,



6

00:00:20,000 --> 00:00:24,000

с секундомером. прототип



7

00:00:24,000 --> 00:00:28,000

, И, кстати, я использовал



8

00:00:28,000 --> 00:00:32,000

мульти-курсор редактирования здесь, если вы не заметили, так



9

00:00:32,000 --> 00:00:36,000

вы видите здесь, у нас есть несколько курсоров, это быстрый способ редактировать несколько элементов



10

00:00:36,000 --> 00:00:40,000

в то же время. То, как вы делаете это, вы выбираете что-то,



11

00:00:40,000 --> 00:00:44,000

а затем нажмите команду и D, или контроль и D,



12

00:00:44,000 --> 00:00:48,000

на винде. На самом деле, я не уверен насчет ярлыка на Windows, потому что



13

00:00:48,000 --> 00:00:52,000

Я не использую Windows. Но если вы посмотрите на верхнее меню под



14

00:00:52,000 --> 00:00:56,000

меню выбора, смотрите, это тот короткий путь, о котором я говорю,



15

00:00:56,000 --> 00:01:00,000

Добавьте Next Occurrence, чтобы вы выбрали что-то, здесь я выбрал



16

00:01:00,000 --> 00:01:04,000

stopwatch.prototype, теперь мы нажимаем команду и D,



17

00:01:04,000 --> 00:01:08,000

и здесь у нас есть еще один выбор, еще раз,



18

00:01:08,000 --> 00:01:12,000

И это третий раздел. Теперь мы можем заменить все это вместе,



19

00:01:12,000 --> 00:01:16,000

или вернуть его обратно. Так,



20

00:01:16,000 --> 00:01:20,000

эти методы сейчас на прототипе для секундомера.



21

00:01:20,000 --> 00:01:24,000

Как вы можете видеть, запуск не определен нигде в этой функции.



22

00:01:24,000 --> 00:01:28,000

Это определено здесь, и у нас нет доступа к этому. Вот почему нам нужно



23

00:01:28,000 --> 00:01:32,000

определить это как свойство только для чтения, так же, как мы имеем



24

00:01:32,000 --> 00:01:36,000

выставил переменную продолжительности как свойство только для чтения



25

00:01:36,000 --> 00:01:40,000

здесь мы должны выставить эти другие переменные только для чтения



26

00:01:40,000 --> 00:01:44,000

свойства. Теперь проблема в том, что это будет загрязнять



27

00:01:44,000 --> 00:01:48,000

интерфейс секундомера. В нашей предыдущей реализации,



28

00:01:48,000 --> 00:01:52,000

у нашего секундомера было только четыре открытых члена, три метода,



29

00:01:52,000 --> 00:01:56,000

запуск, остановка и сброс, и одно публичное свойство, это



30

00:01:56,000 --> 00:02:00,000

продолжительность. Теперь мы собираемся добавить три дополнительных свойства



31

00:02:00,000 --> 00:02:04,000

и это будет загрязнять интерфейс секундомера. И это против



32

00:02:04,000 --> 00:02:08,000

идея абстракции в объектно-ориентированном программировании. Потому что как



33

00:02:08,000 --> 00:02:12,000

Я объяснил ранее, мы хотим, чтобы интерфейс наших объектов был чистым и простым



34

00:02:12,000 --> 00:02:16,000

так же, как DVD-плеер, мы не хотим раскрывать все детали



35

00:02:16,000 --> 00:02:20,000

на улицу. Итак, давайте определимся



36

00:02:20,000 --> 00:02:24,000

3 общедоступных свойства, на самом деле, чтобы сэкономить время, я собираюсь дублировать



37

00:02:24,000 --> 00:02:28,000

это пару раз,



38

00:02:28,000 --> 00:02:32,000

теперь мы хотим выставить время начала



39

00:02:32,000 --> 00:02:36,000

и здесь мы хотим вернуть startTime. Следующий,



40

00:02:36,000 --> 00:02:40,000

мы хотим выставить время окончания. Здесь я собираюсь использовать редактирование нескольких курсоров



41

00:02:40,000 --> 00:02:44,000

Смотри, я выбрал оба экземпляра продолжительности, и я собираюсь заменить их



42

00:02:44,000 --> 00:02:48,000

с endTime. Еще раз,



43

00:02:48,000 --> 00:02:52,000

на этот раз я собираюсь разоблачить бег.



44

00:02:52,000 --> 00:02:56,000

Хорошо? Теперь вернемся к нашим методам прототипа



45

00:02:56,000 --> 00:03:00,000

так что здесь я собираюсь заменить бег



46

00:03:00,000 --> 00:03:04,000

с этим.



47

00:03:04,000 --> 00:03:08,000

И начать время с этим.



48

00:03:08,000 --> 00:03:12,000

Я собираюсь внести те же изменения в другие методы. Так вот



49

00:03:12,000 --> 00:03:16,000

в методе остановки,



50

00:03:16,000 --> 00:03:20,000

Хорошо, вот то, что мы имеем сейчас, так что есть хитрый



51

00:03:20,000 --> 00:03:24,000

Ситуация здесь, в методе остановки, в последней строке



52

00:03:24,000 --> 00:03:28,000

Вы добавляете секунды к продолжительности.



53

00:03:28,000 --> 00:03:32,000

Теперь длительность является общедоступной собственностью только для чтения.



54

00:03:32,000 --> 00:03:36,000

Поэтому я не могу изменить это так. Потому что в настоящее время



55

00:03:36,000 --> 00:03:40,000

у него нет сеттера. Теперь, если мы вернемся к нашему



56

00:03:40,000 --> 00:03:44,000

конструктор секундомера здесь, мы можем определить



57

00:03:44,000 --> 00:03:48,000

сеттер для этого, чтобы решить эту проблему, но это будет



58

00:03:48,000 --> 00:03:52,000

привести к другой проблеме, так что давайте сначала исправим это, а потом поговорим об этом.



59

00:03:52,000 --> 00:03:56,000

Так что setter, функция, которая принимает значение,



60

00:03:56,000 --> 00:04:00,000

и здесь мы просто устанавливаем длительность на это значение. Сейчас



61

00:04:00,000 --> 00:04:04,000

вернуться к методу остановки, чтобы мы могли получить доступ



62

00:04:04,000 --> 00:04:08,000

свойство duration и обновите его значение. Точно так же в



63

00:04:08,000 --> 00:04:12,000

метод сброса, мы можем установить this.duration. Но это был



64

00:04:12,000 --> 00:04:16,000

ужасная идея Зачем? Потому что я могу создать секундомер здесь,



65

00:04:16,000 --> 00:04:20,000

новый секундомер, а потом просто



66

00:04:20,000 --> 00:04:24,000

изменить эту продолжительность извне.



67

00:04:24,000 --> 00:04:28,000

Теперь это полностью испортит состояние этого объекта. Запомни это



68

00:04:28,000 --> 00:04:32,000

В принципе, ваши объекты всегда должны быть в действительном состоянии.



69

00:04:32,000 --> 00:04:36,000

Мы не хотим, чтобы ваши объекты лгали, мы не хотим, чтобы они были ненадежными и ненадежными.



70

00:04:36,000 --> 00:04:40,000

Вот почему мы используем абстракцию, с абстракцией



71

00:04:40,000 --> 00:04:44,000

вы скрываете ненужную сложность и выставляете



72

00:04:44,000 --> 00:04:48,000

очень мало членов, которые позволили бы клиентам объекта работать



73

00:04:48,000 --> 00:04:52,000

с этим, не портя это состояние. Так что я



74

00:04:52,000 --> 00:04:56,000

разработал это упражнение для вас, чтобы вы могли иногда видеть



75

00:04:56,000 --> 00:05:00,000

Вы вносите некоторые изменения в свой код по причинам оптимизации, но в итоге вы создаете



76

00:05:00,000 --> 00:05:04,000

много других вопросов. В этой программе у нас не было



77

00:05:04,000 --> 00:05:08,000

проблемы с производительностью, и мы знали, что у нас не будет, скажем, 1000



78

00:05:08,000 --> 00:05:12,000

экземпляры секундомера в памяти. Так что выкладываю все



79

00:05:12,000 --> 00:05:16,000

эти методы на прототипе были очень плохой идеей для начала.



80

00:05:16,000 --> 00:05:20,000

Это нарушило принцип абстракции, и теперь мы разоблачаем это



81

00:05:20,000 --> 00:05:24,000

свойство длительности, чтобы мы могли изменить его извне, так по существу



82

00:05:24,000 --> 00:05:28,000

этот объект секундомера теперь бесполезен. Eсть



83

00:05:28,000 --> 00:05:32,000

известная поговорка, которая говорит, что преждевременная оптимизация является корнем



84

00:05:32,000 --> 00:05:36,000

все зло. И вот у нас есть реальный пример преждевременной оптимизации.