1

00:00:00,000 --> 00:00:04,000

Так что у тебя есть



2

00:00:04,000 --> 00:00:08,000

узнал, что каждый объект в JavaScript кроме корневого объекта



3

00:00:08,000 --> 00:00:12,000

имеет прототип или родитель. Теперь правильный способ



4

00:00:12,000 --> 00:00:16,000

получить прототип объекта, используя Object.getPrototype



5

00:00:16,000 --> 00:00:20,000

Из, и здесь мы передаем объект.



6

00:00:20,000 --> 00:00:24,000

Хорошо, и то, что мы получаем здесь, это именно то, что мы видели



7

00:00:24,000 --> 00:00:28,000

в консоли Chrome, под myObject.



8

00:00:28,000 --> 00:00:32,000

__proto свойство. это то же самое



9

00:00:32,000 --> 00:00:36,000

вещь, верно? Итак, что у нас здесь есть прототип



10

00:00:36,000 --> 00:00:40,000

или родитель myObject, верно?



11

00:00:40,000 --> 00:00:44,000

Теперь нужно знать, что конструкторы также



12

00:00:44,000 --> 00:00:48,000

свойство прототипа. Итак, у нас есть



13

00:00:48,000 --> 00:00:52,000

функция конструктора круга. И вы знаете, что в JavaScript,



14

00:00:52,000 --> 00:00:56,000

функции являются объектами, поэтому у них есть свойства и методы.



15

00:00:56,000 --> 00:01:00,000

Итак, здесь мы можем напечатать круг.



16

00:01:00,000 --> 00:01:04,000

посмотрите это все свойства и методы, которые доступны



17

00:01:04,000 --> 00:01:08,000

в каждой функции. Итак, вот свойство прототипа.



18

00:01:08,000 --> 00:01:12,000

Что это? Это объект, который будет использоваться



19

00:01:12,000 --> 00:01:16,000

в качестве родителя для объектов, созданных



20

00:01:16,000 --> 00:01:20,000

конструктор круга Итак, вернемся сюда, если я хочу соединить это,



21

00:01:20,000 --> 00:01:24,000

при условии, что у нас есть этот мой объект, и это мой объект



22

00:01:24,000 --> 00:01:28,000

создан этим конструктором, этот конструктор



23

00:01:28,000 --> 00:01:32,000

имеет свойство прототипа, и что мы получаем здесь



24

00:01:32,000 --> 00:01:36,000

это именно то, что мы имеем здесь.



25

00:01:36,000 --> 00:01:40,000

Таким образом, объект, который будет использоваться в качестве родителя для



26

00:01:40,000 --> 00:01:44,000

объекты, созданные этим конструктором. Позвольте мне показать вам это



27

00:01:44,000 --> 00:01:48,000

В бою. Итак, я собираюсь определить



28

00:01:48,000 --> 00:01:52,000

объект, пустой объект. Этот объект имеет



29

00:01:52,000 --> 00:01:56,000

свойство прототипа, которое является его родителем, и вы знаете, что



30

00:01:56,000 --> 00:02:00,000

это то, что мы называем objectBase. Правильно? Итак, у нас есть эти члены



31

00:02:00,000 --> 00:02:04,000

как конструктор, hasOwnProperty и так далее.



32

00:02:04,000 --> 00:02:08,000

Хорошо? Теперь вы знаете, что этот объект создан



33

00:02:08,000 --> 00:02:12,000

используя функцию конструктора объекта, верно?



34

00:02:12,000 --> 00:02:16,000

Поэтому, когда мы используем буквальный синтаксис объекта, под капотом, это



35

00:02:16,000 --> 00:02:20,000

переведен на новый объект, так что это наш конструктор.



36

00:02:20,000 --> 00:02:24,000

Теперь этот конструктор имеет свойство прототипа



37

00:02:24,000 --> 00:02:28,000

и это объект, который будет использоваться в качестве прототипа



38

00:02:28,000 --> 00:02:32,000

для всех объектов, созданных этим конструктором.



39

00:02:32,000 --> 00:02:36,000

Итак, посмотрите, это наша objectBase, верно?



40

00:02:36,000 --> 00:02:40,000

Итак, что я говорю вам, это то, что оба



41

00:02:40,000 --> 00:02:44,000

они равны. Родитель этого объекта,



42

00:02:44,000 --> 00:02:48,000

и прототип для этого конструктора. Давайте посмотрим на



43

00:02:48,000 --> 00:02:52,000

другой пример. Итак, я собираюсь определить массив,



44

00:02:52,000 --> 00:02:56,000

пустой массив, этот массив имеет прототип, прото



45

00:02:56,000 --> 00:03:00,000

и это объект, который включает в себя



46

00:03:00,000 --> 00:03:04,000

все методы, которые можно вызывать для массивов, верно? Итак, мы называем это



47

00:03:04,000 --> 00:03:08,000

arraybase. Теперь, когда мы используем



48

00:03:08,000 --> 00:03:12,000

литерал массива, под капотом будет вызван конструктор массива.



49

00:03:12,000 --> 00:03:16,000

Теперь этот конструктор имеет свойство прототипа, которое ссылается на



50

00:03:16,000 --> 00:03:20,000

база массива. Тот же объект Хорошо?



51

00:03:20,000 --> 00:03:24,000

Теперь, наконец, в качестве еще одного примера, здесь у нас есть объект круга.



52

00:03:24,000 --> 00:03:28,000

Круг имеет прототип



53

00:03:28,000 --> 00:03:32,000

мы называем основание круга, который не имеет ничего конкретного



54

00:03:32,000 --> 00:03:36,000

здесь он имеет только это свойство конструктора. Сейчас,



55

00:03:36,000 --> 00:03:40,000

мы создали объект круга с помощью конструктора круга.



56

00:03:40,000 --> 00:03:44,000

Этот конструктор имеет свойство прототипа, которое возвращает круг



57

00:03:44,000 --> 00:03:48,000

База. Итак, эти



58

00:03:48,000 --> 00:03:52,000

два объекта абсолютно одинаковы.