1

00:00:00,000 --> 00:00:04,000

Хорошо, вот моя реализация



2

00:00:04,000 --> 00:00:08,000

объект секундомер. Теперь не волнуйтесь, если ваша реализация отличается



3

00:00:08,000 --> 00:00:12,000

от моего, скорее всего, это будет иначе, потому что нет единого решения



4

00:00:12,000 --> 00:00:16,000

к данной проблеме. Пока ваш секундомер ведет себя как



5

00:00:16,000 --> 00:00:20,000

Я показал вам в последней лекции, и она имеет чистую реализацию, ваше решение



6

00:00:20,000 --> 00:00:24,000

отлично в порядке. Итак, здесь у нас есть функция под названием секундомер



7

00:00:24,000 --> 00:00:28,000

это функция конструктора. Я определил несколько



8

00:00:28,000 --> 00:00:32,000

частные переменные здесь, время начала, время окончания,



9

00:00:32,000 --> 00:00:36,000

работает, чтобы увидеть, работает ли секундомер или нет, и продолжительность



10

00:00:36,000 --> 00:00:40,000

который вы изначально установили на 0. Вы можете видеть, что у нас есть



11

00:00:40,000 --> 00:00:44,000

3 метода здесь, запуск, остановка и сброс, и я



12

00:00:44,000 --> 00:00:48,000

также определено свойство только для чтения под названием длительность



13

00:00:48,000 --> 00:00:52,000

посмотрите здесь у нас есть геттер, который просто возвращает



14

00:00:52,000 --> 00:00:56,000

длительность, которая является локальной переменной в этой функции.



15

00:00:56,000 --> 00:01:00,000

Теперь давайте посмотрим на реализацию каждого из этих методов.



16

00:01:00,000 --> 00:01:04,000

Итак, начнем, сначала у нас есть проверка.



17

00:01:04,000 --> 00:01:08,000

Если секундомер работает, мы просто выдаем новую ошибку,



18

00:01:08,000 --> 00:01:12,000

с этим сообщением. Секундомер уже запущен.



19

00:01:12,000 --> 00:01:16,000

В противном случае мы устанавливаем значение true, и



20

00:01:16,000 --> 00:01:20,000

установить время начала текущей даты. Очень простая реализация.



21

00:01:20,000 --> 00:01:24,000

Метод остановки очень похож. Так,



22

00:01:24,000 --> 00:01:28,000

Сначала у нас есть проверка, если она не работает,



23

00:01:28,000 --> 00:01:32,000

очевидно, мы не можем это остановить. Вот почему мы бросаем новую ошибку.



24

00:01:32,000 --> 00:01:36,000

В противном случае, мы устанавливаем бег на ложь, затем,



25

00:01:36,000 --> 00:01:40,000

мы устанавливаем время окончания на текущую дату, а затем вычисляем



26

00:01:40,000 --> 00:01:44,000

секунд между временем окончания и временем начала. Так,



27

00:01:44,000 --> 00:01:48,000

мы вызываем end time.getTime и вычитаем его



28

00:01:48,000 --> 00:01:52,000

от времени начала. время получения. Это выражение возвращает



29

00:01:52,000 --> 00:01:56,000

миллисекунды между этими двумя объектами даты. Таким образом, мы делим это между



30

00:01:56,000 --> 00:02:00,000

1000, чтобы получить секунды, а затем добавить это к продолжительности



31

00:02:00,000 --> 00:02:04,000

переменная, которую мы определили ранее. И наконец,



32

00:02:04,000 --> 00:02:08,000

давайте посмотрим на метод сброса. Здесь мы просто устанавливаем эти переменные



33

00:02:08,000 --> 00:02:12,000

к их первоначальной стоимости. Таким образом, мы устанавливаем startTime и



34

00:02:12,000 --> 00:02:16,000

endTime to null, работает до false и длительность до 0.



35

00:02:16,000 --> 00:02:20,000

Итак, еще раз, если ваша реализация отличается, не волнуйтесь,



36

00:02:20,000 --> 00:02:24,000

нет лучшего решения данной проблемы. Если я вернусь и



37

00:02:24,000 --> 00:02:28,000

Решил эту проблему через месяц, скорее всего, моя реализация будет другой



38

00:02:28,000 --> 00:02:31,600

из того, что вы видите прямо сейчас.