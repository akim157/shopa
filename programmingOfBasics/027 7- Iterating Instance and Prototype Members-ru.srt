1

00:00:00,000 --> 00:00:04,000

Итак, я упростила



2

00:00:04,000 --> 00:00:08,000

пример из последней лекции, у нас есть объект круга с



3

00:00:08,000 --> 00:00:12,000

два элемента экземпляра, радиус и перемещение, и один прототип



4

00:00:12,000 --> 00:00:16,000

член, который называется ничья. Теперь одну вещь, которую я хочу подчеркнуть здесь



5

00:00:16,000 --> 00:00:20,000

в том, что это не имеет значения, когда вы меняете прототип.



6

00:00:20,000 --> 00:00:24,000

Так что в этом случае мы модифицируем прототип перед созданием



7

00:00:24,000 --> 00:00:28,000

объект. Вы можете сначала создать объект,



8

00:00:28,000 --> 00:00:32,000

а затем изменить прототип. Метод розыгрыша все еще будет доступен



9

00:00:32,000 --> 00:00:36,000

на объекте круга, потому что здесь



10

00:00:36,000 --> 00:00:40,000

мы имеем дело с объектными ссылками. Таким образом, у вас есть один объект в памяти



11

00:00:40,000 --> 00:00:44,000

как только мы изменим это, все изменения будут сразу же видны.



12

00:00:44,000 --> 00:00:48,000

Так что сохраните изменения, смотрите, у нас есть сообщение об отрисовке.



13

00:00:48,000 --> 00:00:52,000

Теперь в этой лекции я покажу вам, как перебирать



14

00:00:52,000 --> 00:00:56,000

Свойства экземпляра и прототипа. Так раньше



15

00:00:56,000 --> 00:01:00,000

Вы узнали о методе object.keys.



16

00:01:00,000 --> 00:01:04,000

Я собираюсь передать C1 здесь,



17

00:01:04,000 --> 00:01:08,000

давайте посмотрим, что мы получим на консоли. Так,



18

00:01:08,000 --> 00:01:12,000

сохранить, поэтому объект с ключами только возвращает



19

00:01:12,000 --> 00:01:16,000

члены инстанции. Радиус и двигаться. Рисовать



20

00:01:16,000 --> 00:01:20,000

сейчас там, потому что Draw является прототипом члена. Так вот что я хочу



21

00:01:20,000 --> 00:01:24,000

Вы должны помнить. Так что object.keys только возвращает



22

00:01:24,000 --> 00:01:28,000

члены инстанции. Хорошо?



23

00:01:28,000 --> 00:01:32,000

Что насчет цикла in? Позволь мне показать тебе. Так



24

00:01:32,000 --> 00:01:36,000

для ключа



25

00:01:36,000 --> 00:01:40,000

и c1, давайте просто сделаем console.log



26

00:01:40,000 --> 00:01:44,000

ключ. Хорошо, смотрите, у нас есть



27

00:01:44,000 --> 00:01:48,000

все элементы экземпляра и прототипа. Таким образом, мы получаем метод ничьей



28

00:01:48,000 --> 00:01:52,000

также. Итак, помните, что в цикле



29

00:01:52,000 --> 00:01:56,000

возвращает всех участников. Пример



30

00:01:56,000 --> 00:02:00,000

и прототип. Теперь в JavaScript



31

00:02:00,000 --> 00:02:04,000

В языке мы часто используем слово собственный вместо экземпляра.



32

00:02:04,000 --> 00:02:08,000

Так что в некоторых документах, в некоторых уроках вы можете услышать собственное имущество



33

00:02:08,000 --> 00:02:12,000

против свойства прототипа. Позвольте мне показать вам полезное



34

00:02:12,000 --> 00:02:16,000

метод. Итак, давайте назовем c1



35

00:02:16,000 --> 00:02:20,000

.hasOwnProperty.



36

00:02:20,000 --> 00:02:24,000

Мы передаем имя свойства, скажем, радиус,



37

00:02:24,000 --> 00:02:28,000

это экземпляр или собственное свойство, поэтому мы получаем истину, но если



38

00:02:28,000 --> 00:02:32,000

мы вызываем hasOwnProperty и передаем draw,



39

00:02:32,000 --> 00:02:36,000

мы должны получить ложь, потому что это прототип члена или прототипа



40

00:02:36,000 --> 00:02:39,066

имущество.