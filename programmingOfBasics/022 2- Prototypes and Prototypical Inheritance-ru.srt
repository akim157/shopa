1

00:00:00,000 --> 00:00:04,000

Итак, в последней лекции мы говорили о



2

00:00:04,000 --> 00:00:08,000

классы круга и формы. Но в JavaScript у нас нет



3

00:00:08,000 --> 00:00:12,000

классы. У нас есть только объекты. Итак, как мы можем реализовать



4

00:00:12,000 --> 00:00:16,000

наследование только с использованием объектов? Ну вот



5

00:00:16,000 --> 00:00:20,000

у нас есть объект круга. Мы можем определить другой объект



6

00:00:20,000 --> 00:00:24,000

давайте назовем это shape и добавим все обычное поведение,



7

00:00:24,000 --> 00:00:28,000

или все распространенные методы в этом объекте, такие как вычисления



8

00:00:28,000 --> 00:00:32,000

OptimumLocation. И тогда как-то мы можем связать



9

00:00:32,000 --> 00:00:36,000

объект круга к объекту формы. Теперь мы ссылаемся на объект формы



10

00:00:36,000 --> 00:00:40,000

как прототип круга.



11

00:00:40,000 --> 00:00:44,000

Таким образом, прототип, по сути, является родителем другого объекта,



12

00:00:44,000 --> 00:00:48,000

много курсов и учебных пособий заставляют прототипы казаться настолько запутывающими



13

00:00:48,000 --> 00:00:52,000

и сложно, это не так. Всякий раз, когда вы слышите слово прототип, просто подумайте



14

00:00:52,000 --> 00:00:56,000

Родитель. Так что каждый объект в JavaScript, кроме



15

00:00:56,000 --> 00:01:00,000

только один объект, который я собираюсь показать вам в секунду, имеет прототип



16

00:01:00,000 --> 00:01:04,000

для родителей. И это наследует всех членов, которых мы находим



17

00:01:04,000 --> 00:01:08,000

в его прототипе. Позвольте мне показать вам это в действии.



18

00:01:08,000 --> 00:01:12,000

Итак, здесь, в Chrome Developer Tools, я собираюсь определить



19

00:01:12,000 --> 00:01:16,000

новый объект, просто пустой объект. Теперь давайте



20

00:01:16,000 --> 00:01:20,000

проверить это. Итак, посмотрите здесь у нас есть



21

00:01:20,000 --> 00:01:24,000

свойство называется прото. Обратите внимание, что это свойство



22

00:01:24,000 --> 00:01:28,000

исчез, потому что это устарело, и вы не должны иметь к нему прямой доступ.



23

00:01:28,000 --> 00:01:32,000

Он доступен только здесь, чтобы помочь вам решить проблемы. Итак, начнем



24

00:01:32,000 --> 00:01:36,000

разверните это, хорошо, смотрите, это прототип,



25

00:01:36,000 --> 00:01:40,000

или родитель, для этого объекта х, который мы создали здесь.



26

00:01:40,000 --> 00:01:44,000

У нас есть эти свойства и методы, как конструктор, вы видели, что в прошлом



27

00:01:44,000 --> 00:01:48,000

раздел. Таким образом, каждый объект имеет свойство конструктора



28

00:01:48,000 --> 00:01:52,000

которая ссылается на функцию, которая использовалась для создания или создания



29

00:01:52,000 --> 00:01:56,000

этот объект. У нас также есть этот объект здесь toString



30

00:01:56,000 --> 00:02:00,000

Итак, давайте использовать этот метод,



31

00:02:00,000 --> 00:02:04,000

Вы можете ввести x.toString.



32

00:02:04,000 --> 00:02:08,000

И это реализация по умолчанию двухстрочного метода.



33

00:02:08,000 --> 00:02:12,000

Таким образом, у нас есть этот объект х в памяти. И х имеет ссылку



34

00:02:12,000 --> 00:02:16,000

к другому объекту, который является его прототипом. Для нашего обсуждения



35

00:02:16,000 --> 00:02:20,000

давайте назовем этот объект objectBase. Это не официальный



36

00:02:20,000 --> 00:02:24,000

термин, мы не собираемся его нигде искать, это просто имя, которое я собираюсь дать



37

00:02:24,000 --> 00:02:28,000

наше обсуждение. Таким образом, каждый объект, который мы создаем в JavaScript



38

00:02:28,000 --> 00:02:32,000

прямо или косвенно наследуется от объектной базы.



39

00:02:32,000 --> 00:02:36,000

objectBase является корнем всех объектов в JavaScript



40

00:02:36,000 --> 00:02:40,000

и у него нет прототипа или родителя, позвольте мне показать вам.



41

00:02:40,000 --> 00:02:44,000

Итак, еще раз, давайте проверим х,



42

00:02:44,000 --> 00:02:48,000

хорошо, вот его прототип, который является нашей объектной базой.



43

00:02:48,000 --> 00:02:52,000

Смотри, этот объект не имеет прото



44

00:02:52,000 --> 00:02:56,000

имущество. Так что у него нет прототипа или родителя.



45

00:02:56,000 --> 00:03:00,000

Теперь мы можем создать еще один объект здесь, давайте назовем это у,



46

00:03:00,000 --> 00:03:04,000

опять еще один пустой объект, давайте проверим



47

00:03:04,000 --> 00:03:08,000

Это. Итак, у также есть свойство прототипа



48

00:03:08,000 --> 00:03:12,000

который является той же objectBase, что вы видели несколько



49

00:03:12,000 --> 00:03:16,000

секунд назад. Итак, вот что у нас в памяти. У нас есть х и у,



50

00:03:16,000 --> 00:03:20,000

и оба эти объекта ссылаются на объектную базу.



51

00:03:20,000 --> 00:03:24,000

Таким образом, у нас есть единственный экземпляр objectBase в памяти.



52

00:03:24,000 --> 00:03:28,000

Я могу доказать это вам. Итак, вернемся в консоль,



53

00:03:28,000 --> 00:03:32,000

чтобы получить прототип объекта, мы вызываем объект.



54

00:03:32,000 --> 00:03:36,000

getPrototypeOf, и здесь мы проходим



55

00:03:36,000 --> 00:03:40,000

х, так,



56

00:03:40,000 --> 00:03:44,000

это наша объектная база. С этими членами, хорошо?



57

00:03:44,000 --> 00:03:48,000

Теперь мы можем написать такое выражение.



58

00:03:48,000 --> 00:03:52,000

Object.getPrototype из x



59

00:03:52,000 --> 00:03:56,000

мы можем проверить, если он равен object.getPrototype



60

00:03:56,000 --> 00:04:00,000

Смотри, оба



61

00:04:00,000 --> 00:04:04,000

х и у имеют точно такой же прототип. Теперь вы можете быть удивлены



62

00:04:04,000 --> 00:04:08,000

почему я не написал это выражение, как это, х.



63

00:04:08,000 --> 00:04:12,000

__proto = y



64

00:04:12,000 --> 00:04:16,000

.__ прот. Причина этого в том, что



65

00:04:16,000 --> 00:04:20,000

это свойство устарело, поэтому его не следует использовать в коде. Но вы можете



66

00:04:20,000 --> 00:04:24,000

используйте это здесь на консоли при отладке ваших приложений.



67

00:04:24,000 --> 00:04:28,000

Итак, теперь, когда вы понимаете, что такое прототип, давайте определимся



68

00:04:28,000 --> 00:04:32,000

прототип наследования. Так что раньше я получаю доступ к



69

00:04:32,000 --> 00:04:36,000

Строковый метод для объекта x, мы не определили это



70

00:04:36,000 --> 00:04:40,000

метод в нашем объекте x, потому что x был пустым объектом, верно?



71

00:04:40,000 --> 00:04:44,000

Итак, как это работает, как мы можем получить доступ к этому методу? Что ж,



72

00:04:44,000 --> 00:04:48,000

когда мы получаем доступ к свойству или методу объекта, Java



73

00:04:48,000 --> 00:04:52,000

Скриптовый движок сначала ищет это свойство или метод на



74

00:04:52,000 --> 00:04:56,000

сам объект. Если он не может его найти, он смотрит на



75

00:04:56,000 --> 00:05:00,000

прототип для этого объекта. Опять же, если он может найти этого члена,



76

00:05:00,000 --> 00:05:04,000

он будет смотреть на прототип этого объекта вплоть до



77

00:05:04,000 --> 00:05:08,000

к корневому объекту, который мы называем objectBase. Так



78

00:05:08,000 --> 00:05:12,000

это прототип наследования в действии. При доступе



79

00:05:12,000 --> 00:05:16,000

свойство или метод объекта, метод JavaScript



80

00:05:16,000 --> 00:05:20,000

макетирует цепочку прототипов, чтобы найти целевой элемент. Так,



81

00:05:20,000 --> 00:05:24,000

еще раз хочу подчеркнуть, что прототип - это просто обычный



82

00:05:24,000 --> 00:05:28,000

объект в памяти. В этом нет ничего особенного. Каждый объект имеет



83

00:05:28,000 --> 00:05:32,000

прототип или родитель, кроме корневого объекта.