1

00:00:00,000 --> 00:00:04,000

Теперь у нас есть



2

00:00:04,000 --> 00:00:08,000

конструктор круга с двумя членами, свойство radius



3

00:00:08,000 --> 00:00:12,000

и метод рисования, как и раньше, и у нас есть два



4

00:00:12,000 --> 00:00:16,000

круг объектов. Итак, давайте зарегистрируем эти объекты на консоли.



5

00:00:16,000 --> 00:00:20,000

с1, вот наш объект, мы имеем



6

00:00:20,000 --> 00:00:24,000

этот метод рисования, давайте войдем в c2,



7

00:00:24,000 --> 00:00:28,000

и вы можете видеть, что у нас есть этот метод рисования здесь. Так,



8

00:00:28,000 --> 00:00:32,000

в текущей реализации, скажем, если у нас есть 1000



9

00:00:32,000 --> 00:00:36,000

объекты в памяти, у нас будет 1000 копий



10

00:00:36,000 --> 00:00:40,000

метода ничьей. Теперь это очень упрощенный пример,



11

00:00:40,000 --> 00:00:44,000

в реальном приложении ваши объекты могут иметь несколько методов,



12

00:00:44,000 --> 00:00:48,000

так что если вы хотите иметь большое количество этих объектов в памяти,



13

00:00:48,000 --> 00:00:52,000

вы собираетесь тратить много памяти, сохраняя копии



14

00:00:52,000 --> 00:00:56,000

все эти методы. Так в чем же решение? Ну ты знаешь



15

00:00:56,000 --> 00:01:00,000

как работает прототип наследования. Когда мы получаем доступ к собственности



16

00:01:00,000 --> 00:01:04,000

или метод объекта, механизм JavaScript сначала смотрит на



17

00:01:04,000 --> 00:01:08,000

сам объект, если он не может найти это свойство или метод, он будет выглядеть



18

00:01:08,000 --> 00:01:12,000

на прототипе этого объекта. А сейчас,



19

00:01:12,000 --> 00:01:16,000

Вы можете взять этот метод рисования из объекта круга и поместить его в



20

00:01:16,000 --> 00:01:20,000

это прототип, у нас будет один экземпляр этого прототипа в



21

00:01:20,000 --> 00:01:24,000

память, которую мы называем кругом базы, поэтому мы будем иметь один экземпляр



22

00:01:24,000 --> 00:01:28,000

метода ничьей. Итак, как мы это делаем?



23

00:01:28,000 --> 00:01:32,000

Ну, в последней лекции вы узнали, что каждый consturctor



24

00:01:32,000 --> 00:01:36,000

имеет свойство прототипа. Так круг.прототип



25

00:01:36,000 --> 00:01:40,000

и это точно так же, как прототип



26

00:01:40,000 --> 00:01:44,000

из нашего круга объектов. Итак, для c1, скажем,



27

00:01:44,000 --> 00:01:48,000

если вы обращаетесь к свойству proto, чего не следует делать, потому что оно устарело,



28

00:01:48,000 --> 00:01:52,000

но по сути эти два свойства ссылаются на один и тот же объект



29

00:01:52,000 --> 00:01:56,000

в памяти. Это основа круга. Так,



30

00:01:56,000 --> 00:02:00,000

используя circle.prototype, мы можем быстро



31

00:02:00,000 --> 00:02:04,000

и безопасно получить доступ к этому объекту. Так,



32

00:02:04,000 --> 00:02:08,000

Вы знаете, что объекты JavaScript являются динамическими, поэтому мы всегда можем добавить к ним что-нибудь позже.



33

00:02:08,000 --> 00:02:12,000

Итак, мы можем добавить метод рисования здесь,



34

00:02:12,000 --> 00:02:16,000

и просто переместить реализацию



35

00:02:16,000 --> 00:02:20,000

Прямо здесь. И с этим нам больше не нужно



36

00:02:20,000 --> 00:02:24,000

метод рисования на самом экземпляре объекта.



37

00:02:24,000 --> 00:02:28,000

Сохранить. Итак, давайте войдем



38

00:02:28,000 --> 00:02:32,000

наши круги еще раз c1. это



39

00:02:32,000 --> 00:02:36,000

объект имеет только свойство radius, метод draw



40

00:02:36,000 --> 00:02:40,000

находится на прототипе, круг базовый объект, верно?



41

00:02:40,000 --> 00:02:44,000

И то же самое верно для c2. Снова,



42

00:02:44,000 --> 00:02:48,000

у нас нет метода рисования, он на прототипе, сейчас,



43

00:02:48,000 --> 00:02:52,000

из-за прототипного наследования мы все еще можем получить к нему доступ, поэтому мы можем вызвать



44

00:02:52,000 --> 00:02:56,000

c1.draw, и все работает. Так по сути



45

00:02:56,000 --> 00:03:00,000

у нас есть два вида свойств и методов в JavaScript.



46

00:03:00,000 --> 00:03:04,000

У нас есть экземпляр, свойства и методы,



47

00:03:04,000 --> 00:03:08,000

давайте назовем членов этого экземпляра, и



48

00:03:08,000 --> 00:03:12,000

прототип участников. Теперь давайте перейдем на следующий уровень.



49

00:03:12,000 --> 00:03:16,000

Итак, вы знаете, что у каждого объекта есть этот метод toString.



50

00:03:16,000 --> 00:03:20,000

Итак, c1.toString. От



51

00:03:20,000 --> 00:03:24,000

по умолчанию возвращает эту строку здесь. Мы можем переписать реализацию



52

00:03:24,000 --> 00:03:28,000

этого метода в прототипе нашего круга объектов.



53

00:03:28,000 --> 00:03:32,000

Итак, здесь я собираюсь добавить круг



54

00:03:32,000 --> 00:03:36,000

.prototype.toString, установите его в



55

00:03:36,000 --> 00:03:40,000

новая функция, и здесь мы собираемся вернуться



56

00:03:40,000 --> 00:03:44,000

Круг с радиусом



57

00:03:44,000 --> 00:03:48,000

Теперь нам нужно получить доступ к свойству radius, так что



58

00:03:48,000 --> 00:03:52,000

мы можем использовать это.радиус.



59

00:03:52,000 --> 00:03:56,000

Сохраните изменения, сейчас,



60

00:03:56,000 --> 00:04:00,000

c1.toString. И это



61

00:04:00,000 --> 00:04:04,000

новая реализация. Итак, вернемся к нашему прототипу наследства, когда мы



62

00:04:04,000 --> 00:04:08,000

вызвать этот метод движок JavaScript, очевидно, смотрит на наш объект круга



63

00:04:08,000 --> 00:04:12,000

у нас нет этого метода там, то он смотрит на его прототип,



64

00:04:12,000 --> 00:04:16,000

поэтому circle.prototype, мы реализовали этот метод



65

00:04:16,000 --> 00:04:20,000

здесь, так что эта реализация будет использоваться. Так вот



66

00:04:20,000 --> 00:04:24,000

интересная часть Хотя у нас есть другая реализация



67

00:04:24,000 --> 00:04:28,000

метода toString, на objectBase, но эта реализация будет



68

00:04:28,000 --> 00:04:32,000

использовать, потому что это более доступно. Так что это все



69

00:04:32,000 --> 00:04:36,000

об экземпляре против членов-прототипов. И кстати



70

00:04:36,000 --> 00:04:40,000

помните, что в обоих типах участников вы можете ссылаться на других участников.



71

00:04:40,000 --> 00:04:44,000

Например, в методе рисования, который является методом-прототипом,



72

00:04:44,000 --> 00:04:48,000

Я могу легко вызвать метод экземпляра в классе круга.



73

00:04:48,000 --> 00:04:52,000

Итак, давайте добавим метод здесь и назовем его так,



74

00:04:52,000 --> 00:04:56,000

Переместите его в функцию,



75

00:04:56,000 --> 00:05:00,000

console.log о движении.



76

00:05:00,000 --> 00:05:04,000

Теперь мы можем более точно ссылаться на эту функцию или этот метод



77

00:05:04,000 --> 00:05:08,000

в нашем методе прототипа. Так это



78

00:05:08,000 --> 00:05:12,000

.move, а затем console.log капли. Так



79

00:05:12,000 --> 00:05:16,000

давайте проверим это. с1 плюс капля



80

00:05:16,000 --> 00:05:20,000

и вот наши два сообщения, переместить и отпустить. К тому же,



81

00:05:20,000 --> 00:05:24,000

в методе экземпляра мы можем ссылаться на прототип



82

00:05:24,000 --> 00:05:28,000

член. Итак, давайте изменим это. Здесь раньше



83

00:05:28,000 --> 00:05:32,000

двигая круг мы хотим нарисовать его. Итак, мы называем это.



84

00:05:32,000 --> 00:05:36,000

ничья, теперь по сути то, что здесь происходит, мы называем



85

00:05:36,000 --> 00:05:40,000

метод draw, очевидно, это не метод экземпляра. Так что JavaScript



86

00:05:40,000 --> 00:05:44,000

двигатель, найдем этот метод по прототипу, так что все



87

00:05:44,000 --> 00:05:48,000

будет продолжать работать. Чтобы продемонстрировать это, давайте вернемся к розыгрышу



88

00:05:48,000 --> 00:05:52,000

метод, мы не должны вызывать движение, потому что в противном случае у нас будет круг



89

00:05:52,000 --> 00:05:56,000

зависимость. Так что удалите это, сохраните изменения,



90

00:05:56,000 --> 00:06:00,000

сейчас, c1.move



91

00:06:00,000 --> 00:06:04,000

поэтому мы должны рисовать и двигаться.