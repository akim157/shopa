/*===================== Functions ======================= */
//Функции являются полноценными объектами встроенного класса Function.
//В начале работы каждая функция создает внутри себя переменную arguments и присваивает arguments.callee ссылку на себя.
function f() {
    var fun = arguments.callee; //ссылка на себя
    ////////////////////
    var args = Array.prototype.slice.call(arguments); //превщаем параметры функции в массив
}
f.apply(null, [1,2,3]); //Вызвать функцию для массива аргументов можно при помощи apply
f.call({}, 1); //или используя метод call
f.bind(this, arg1, arg2, ..., argN); //Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.
/*===================== Math ============================= */
//Объект Math является встроенным объектом, хранящим в своих свойствах и методах различные математические константы и функции. Объект Math не является функциональным объектом.
Math.floor(1.3); //возвращает целое число
Math.PI; //число PI
/*===================== Number =========================== */
//Объект Number является объектом-обёрткой, позволяющей вам работать с числовыми значениями. Объект Number создаётся через конструктор Number().
typeof NaN; //возвращает number
let num = new Number(); // 1,2,3...
/*===================== Object =========================== */
//Конструктор Object создаёт объект-обёртку.
let obj = new Object();
////////////////////////////////////
const courses = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
];
const course = courses.find(function(course) {
    return course.name === 'a';
}); // { id: 1, name: 'a' }
Object.keys(); //Метод Object.keys() возвращает массив из собственных перечисляемых свойств переданного объекта, в том же порядке, в котором они бы обходились циклом for...in (разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов).
Object.entries(); //Object.entries() метод возвращает массив собственных перечисляемых свойств указанного объекта в формате [key, value], в том же порядке, что и в цикле for...in (разница в том, что for-in также перечисляет свойства из цепочки прототипов).
Object.assign(); //Метод Object.assign() используется для копирования значений всех собственных перечисляемых свойств из одного или более исходных объектов в целевой объект. После копирования он возвращает целевой объект.
/*===================== String =========================== */
//Глобальный объект String является конструктором строк, или, последовательностей символов.
let str = new String(); // '', "", ``
///////////////////////////////////
const another = new String('hi'); //typeof another "object"
///////////////////////////////////
const name = 'John';
const message = 'Hi ' + name + ',\n';
const another =
    `Hi ${name} ${2 + 3},
    
    Thank you for joining my mailing list.
    
    Regards,
    Maxim`;
///////////////////////////////////
const message = 'This is my first message';
message.length; //получаем количество символов в строке - 24
message[0]; //получаем конкретный элемент строки - Т (Доступна с ECMAScript 5)
message.includes('my'); //Метод includes() определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false. - true
message.startsWith('This'); //Метод startsWith() определяет, начинается ли строка с символов другой строки, возвращая, соотвественно, true или false. - true
message.indexOf('my'); //Метод indexOf() возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет. - 8
message.replace('first', 'second'); //Метод replace() возвращает новую строку с некоторыми или всеми сопоставлениями с шаблоном, заменёнными на заменитель. Шаблон может быть строкой или регулярным выражением, а заменитель может быть строкой или функцией, вызываемой при каждом сопоставлении. - This is my second message
message.toUpperCase(); //Метод toUpperCase() возвращает значение строки, на которой он был вызван, преобразованное в верхний регистр. - THIS IS MY FIRST MESSAGE
message.trim(); //Метод trim() удаляет пробельные символы с начала и конца строки.
message.split(); //Метод split() разбивает объект String на массив строк путём разделения строки указанной подстрокой. - []
message.split(' '); //[This, is, my, first, message]
/*===================== Boolean ========================== */
//Объект Boolean является объектом-обёрткой над примитивом логического типа.
let bool = new Boolean(); //true, false
/*===================== Date ============================== */
//Создаёт экземпляр объекта Date, представляющего собой момент времени. Объекты даты Date основываются на значении количества миллисекунд, прошедших с 1 января 1970 года в часовом поясе UTC.
const now = new Date(); //Sat Jun 08 2019 21:51:02 GMT+0300 (Москва, стандартное время)
//В параметрах можно указывать любые типы даты.
const date1 = new Date('May 11 2018 09:00'); //Fri May 11 2018 09:00:00 GMT+0300 (Москва, стандартное время)
const date2 = new Date(2018, 4, 11, 9); //Fri May 11 2018 09:00:00 GMT+0300 (Москва, стандартное время)
const date3 = new Date('05.05.2019'); //Sun May 05 2019 00:00:00 GMT+0300 (Москва, стандартное время)
///////////////////////////////////
now.setFullYear(2017); //Перезаписывает год - Thu Jun 08 2017 21:55:22 GMT+0300 (Москва, стандартное время)
now.toDateString(); //Метод toDateString() возвращает часть, содержащую только дату объекта Date в виде человеко-читаемой строки на американском английском. - Sat Jun 08 2019
now.toTimeString(); //Метод toTimeString() возвращает часть, содержащую только время объекта Date в виде человеко-читаемой строки на американском английском. - 11:35:01 GMT-0700 (PDT)
now.toISOString(); //Метод toISOString() возвращает строку в формате ISO (расширенный формат ISO 8601), который можно описать следующим образом: YYYY-MM-DDTHH:mm:ss.sssZ. Часовой пояс всегда равен UTC, что обозначено суффиксом "Z". - 2017-05-11T18:35:01.212Z
/*===================== Array ============================== */
//Массив (Array) в JavaScript является глобальным объектом, который используется для создания массивов; которые представляют собой высокоуровневые спископодобные объекты.
const numbers = [1,2,3]; //создаем массив
numbers.push(4,5); //Добавление элемента в конец массива
numbers.unshift(1,2); //Добавление элемента в начало массива
numbers.splice(2,0, 'a', 'b'); //Добавление элемента в середину массива
numbers.splice(2,1); //Удаление элемента с определённым индексом
numbers.pop(); //Удаление последнего элемента массива
numbers.shift(); //Удаление первого элемента массива
numbers.indexOf('a'); //Поиск элемента в массиве - -1
numbers.indexOf(1); //Поиск элемента в массиве - 0
numbers.indexOf('1'); //Поиск элемента в массиве - -1
numbers.lastIndexOf(1); //Поиск последнего элемента в массиве
numbers.slice(); //Создание копии массива
numbers.slice(0,2); //можно указвать копировать не весь массив
numbers.includes(4); //Определяет, содержится ли в массиве указанный элемент, возвращая, соответственно, true или false. Он доступен и для строк, и для массивов.
numbers.join(','); //Объединяет все элементы массива в строку. - 1,2,3
numbers.sort(); //Сортировка массива
numbers.reverse(); //Переворачивает порядок элементов в массиве — первый элемент становится последним, а последний — первым.
numbers.every(callback); //Метод every() проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.
numbers.some(callback); //Метод some() проверяет, удовлетворяет ли хоть какой-нибудь элемент массива условию, заданному в передаваемой функции.
numbers.filter(callback); //Создаёт новый массив со всеми элементами этого массива, для которых функция фильтрации возвращает true
numbers.map(callback); //Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.
numbers.reduce(callback); //Метод reduce() применяет функцию к аккумулятору и каждому значению массива (слева-направо), сводя его к одному значению.
////////////////////////////////////
numbers.find(function(element, index, array){
    return element === 1;
}); //Возвращает искомое значение в массиве, если элемент в массиве удовлетворяет условию проверяющей функции или undefined, если такое значение не найдено.
numbers.findIndex(callback); //Метод findIndex() возвращает индекс в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае возвращается -1.
////////////////////////////////////
const second = [4,5,6];
numbers.concat(second); //Возвращает новый массив, состоящий из данного массива, соединённого с другим массивом и/или значением (списком массивов/значений). - [1,2,3,4,5,6]
////////////////////////////////////
//Итерирование по массиву
numbers.forEach(function(item, index, array) {
    console.log(item, index);
});
////////////////////////////////////
Object.keys(numbers); //Возвращает новый итератор массива, содержащий ключи каждого индекса в массиве.





